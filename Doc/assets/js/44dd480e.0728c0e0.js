"use strict";(self.webpackChunkmodio_docs=self.webpackChunkmodio_docs||[]).push([[1094],{50679:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var t=s(74848),o=s(28453);const i={id:"ue-subscribing",title:"Subscribing to UGC",slug:"/unreal/subscribing"},r="Subscribing to UGC",a={id:"getting-started/ue-subscribing",title:"Subscribing to UGC",description:"So you\u2019ve shown the user a variety of UGC, and they've picked one they\u2019d like to install. How do you begin the installation process? What's more, once UGC is installed, how do you know what files to load into memory?",source:"@site/public/en-us/getting-started/ue-subscribing.mdx",sourceDirName:"getting-started",slug:"/unreal/subscribing",permalink:"/unreal/subscribing",draft:!1,unlisted:!1,editUrl:"https://github.com/modio/modio-docs/tree/main/public/en-us/getting-started/ue-subscribing.mdx",tags:[],version:"current",frontMatter:{id:"ue-subscribing",title:"Subscribing to UGC",slug:"/unreal/subscribing"},sidebar:"sidebar",previous:{title:"Searching for UGC",permalink:"/unreal/searching-ugc"},next:{title:"Adding UGC",permalink:"/unreal/adding-ugc"}},d={},l=[{value:"Subscriptions",id:"subscriptions",level:2},{value:"External subscription changes",id:"external-subscription-changes",level:2},{value:"Checking the user subscription list",id:"checking-the-user-subscription-list",level:2},{value:"Installation management",id:"installation-management",level:2},{value:"Retrieving UGC directory paths for loading",id:"retrieving-ugc-directory-paths-for-loading",level:2},{value:"Next steps",id:"next-steps",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components},{TabItem:i,Tabs:r}=n;return i||h("TabItem",!0),r||h("Tabs",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"subscribing-to-ugc",children:"Subscribing to UGC"}),"\n",(0,t.jsx)(n.p,{children:"So you\u2019ve shown the user a variety of UGC, and they've picked one they\u2019d like to install. How do you begin the installation process? What's more, once UGC is installed, how do you know what files to load into memory?"}),"\n",(0,t.jsx)(n.p,{children:"This guide covers:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#subscriptions",children:"Subscriptions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#external-subscription-changes",children:"External subscription changes"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#checking-the-user-subscription-list",children:"Checking the user subscription list"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#installation-management",children:"Installation management"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#retrieving-ugc-directory-paths-for-loading",children:"Retrieving UGC directory paths for loading"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"subscriptions",children:"Subscriptions"}),"\n",(0,t.jsxs)(n.p,{children:["Users indicate they want to install UGC by ",(0,t.jsx)(n.strong,{children:"subscribing"})," to it. Subscriptions are stored on the mod.io servers and are associated with a user\u2019s mod.io account. This means subscribed UGC will be installed to all devices where a user logs into mod.io for that game.  Similarly, when a user ",(0,t.jsx)(n.strong,{children:"unsubscribes"})," from UGC, that UGC will be uninstalled from every device they\u2019re logged into mod.io with for that game."]}),"\n",(0,t.jsxs)(n.p,{children:["Subscriptions are managed with calls to either ",(0,t.jsx)(n.a,{href:"/unreal/refdocs#subscribetomodasync",children:(0,t.jsx)(n.code,{children:"SubscribeToModAsync"})})," or ",(0,t.jsx)(n.a,{href:"/unreal/refdocs#unsubscribefrommodasync",children:(0,t.jsx)(n.code,{children:"UnsubscribeFromModAsync"})})," containing the desired ",(0,t.jsx)(n.code,{children:"ModioModID"})," and a delegate to receive the status of the request."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["To subscribe or unsubscribe from UGC, ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#enablemodmanagement",children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"EnableModManagement"})})})," ",(0,t.jsx)(n.em,{children:"must"})," be called beforehand."]})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"SubscribeToModAsync"})," also takes a bool indicating whether or not to to subscribe to any and all dependencies for the given ",(0,t.jsx)(n.code,{children:"ModioModID"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["When dependencies are included in the ",(0,t.jsx)(n.code,{children:"SubscribeToModAsync"})," call, they will ",(0,t.jsx)(n.em,{children:"not"})," download automatically. ",(0,t.jsxs)(n.strong,{children:["Only the primary UGC specified by ",(0,t.jsx)(n.code,{children:"ModioModID"})," will download automatically."]}),"  To download all subscribed content including dependencies, call ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#fetchexternalupdatesasync",children:(0,t.jsx)(n.code,{children:"FetchExternalUpdatesAsync"})})," after ",(0,t.jsx)(n.code,{children:"SubscribeToModAsync"})," successfully completes."]})}),"\n",(0,t.jsxs)(r,{"group-id":"languages",children:[(0,t.jsxs)(i,{value:"blueprint",label:"Blueprint",children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"subscribe_to_mod",src:s(31974).A+"",width:"898",height:"550"})}),(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"unsubscribe_from_mod",src:s(26300).A+"",width:"943",height:"547"})})]}),(0,t.jsx)(i,{value:"c++",label:"C++",default:!0,children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"void UModioManagerSubsystem::SubscribeToMod(FModioModID ModToSubscribeTo, bool IncludeDependencies)\r\n{\r\n   if (UModioSubsystem* Subsystem = GEngine->GetEngineSubsystem<UModioSubsystem>())\r\n   {\r\n   \tSubsystem->SubscribeToModAsync(ModId, IncludeDependencies, FOnErrorOnlyDelegateFast::CreateUObject(this, &UModioManagerSubsystem::OnSubscribeToModComplete, ModId));\r\n   }\r\n}\r\n\r\nvoid UModioManagerSubsystem::OnSubscribeToModComplete(FModioErrorCode ErrorCode, FModioModID ModId)\r\n{\r\n   if (!ErrorCode)\r\n   {\r\n   \t// Indicate success to your user. This ModId's files will begin installing.\r\n   \t// Call FetchExternalUpdatesAsync if dependencies were included \r\n   }\r\n}\r\n\r\nvoid UModioManagerSubsystem::UnsubscribeFromMod(FModioModID ModId)\r\n{\r\n   if (UModioSubsystem* Subsystem = GEngine->GetEngineSubsystem<UModioSubsystem>())\r\n   {\r\n   \tSubsystem->UnsubscribeFromModAsync(ModId, FOnErrorOnlyDelegateFast::CreateUObject(this, &UModioManagerSubsystem::OnUnsubscribeFromModComplete, ModId));\r\n   }\r\n}\r\n\r\nvoid UModioManagerSubsystem::OnUnsubscribeFromModComplete(FModioErrorCode ErrorCode, FModioModId ModId)\r\n{\r\n   if (!ErrorCode)\r\n   {\r\n   \t// Indicate success to your user. This ModID's files will begin uninstalling.\r\n   }\r\n}\n"})})})]}),"\n",(0,t.jsx)(n.h2,{id:"external-subscription-changes",children:"External subscription changes"}),"\n",(0,t.jsx)(n.p,{children:"Because mod.io's services are available via our website, users can manage their subscriptions outside of your application. This means that we need to be able to query the server for any external subscription changes."}),"\n",(0,t.jsxs)(n.p,{children:["Call ",(0,t.jsx)(n.a,{href:"/unreal/refdocs#fetchexternalupdatesasync",children:(0,t.jsx)(n.code,{children:"FetchExternalUpdatesAsync"})})," to synchronise the server state with the plugin\u2019s local subscriptions.  Any required installations or uninstallations based on the updated user subscriptions will be processed automatically."]}),"\n",(0,t.jsxs)(r,{"group-id":"languages",children:[(0,t.jsx)(i,{value:"blueprint",label:"Blueprint",children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"fetch_external_updates",src:s(12102).A+"",width:"737",height:"364"})})}),(0,t.jsx)(i,{value:"c++",label:"C++",default:!0,children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"\r\nvoid UModioManagerSubsystem::FetchExternalUpdates()\r\n{\r\n   if (UModioSubsystem* Subsystem = GEngine->GetEngineSubsystem<UModioSubsystem>())\r\n   {\r\n   \tSubsystem->FetchExternalUpdatesAsync(FOnErrorOnlyDelegateFast::CreateUObject(this, &UModioManagerSubsystem::OnFetchExternalUpdatesComplete));\r\n   }\r\n}\r\n\r\nvoid UModioManagerSubsystem::OnFetchExternalUpdatesComplete(FModioErrorCode ErrorCode)\r\n{\r\n   // error handling etc.\r\n}\r\n\n"})})})]}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsxs)(n.p,{children:["Call ",(0,t.jsx)(n.a,{href:"/unreal/refdocs#fetchexternalupdatesasync",children:(0,t.jsx)(n.code,{children:"FetchExternalUpdatesAsync"})})," sparingly, only when required to ensure that the local state is up-to-date such as on game start-up or based on user input (i.e. as a button on your UI). It should ",(0,t.jsx)(n.strong,{children:"NOT"})," be called on tick."]})}),"\n",(0,t.jsx)(n.h2,{id:"checking-the-user-subscription-list",children:"Checking the user subscription list"}),"\n",(0,t.jsxs)(n.p,{children:["To see which UGC the user has subscribed to, call ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#query-user-subscriptions",children:(0,t.jsx)(n.code,{children:"QueryUserSubscriptions"})}),".  This retrieves a ",(0,t.jsx)(n.code,{children:"TMap"})," of ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#modiomodcollectionentry",children:(0,t.jsx)(n.code,{children:"ModioModCollectionEntry"})})," objects, one for each subscribed piece of UGC. Each ",(0,t.jsx)(n.code,{children:"ModioModCollectionEntry"})," object contains the UGC's state, profile information, ID and more."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["This collection includes UGC that are still in the process of being installed! Make sure to check the result of ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#get-mod-state",children:(0,t.jsx)(n.code,{children:"GetModState"})})," before attempting to load files from the UGC in this collection.  Alternatively, use ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#query-user-installations",children:(0,t.jsx)(n.code,{children:"QueryUserInstallations"})})," as described in ",(0,t.jsx)(n.a,{href:"#retrieving-ugc-directory-paths-for-loading",children:(0,t.jsx)(n.strong,{children:"Retrieving UGC directory paths for loading"})}),"."]})}),"\n",(0,t.jsxs)(r,{"group-id":"languages",children:[(0,t.jsx)(i,{value:"blueprint",label:"Blueprint",children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"query_user_subscriptions",src:s(2030).A+"",width:"915",height:"357"})})}),(0,t.jsx)(i,{value:"c++",label:"C++",default:!0,children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"void UModioManagerSubsystem::QueryUserSubscriptions()\r\n{\r\n   if (UModioSubsystem* Subsystem = GEngine->GetEngineSubsystem<UModioSubsystem>())\r\n   {\r\n   \tTMap<FModioModID, FModioModCollectionEntry> SubscribedMods = Subsystem->QueryUserSubscriptions();\r\n   \t// Do something with SubscribedMods e.g. display on a UI\r\n   }\r\n}\n"})})})]}),"\n",(0,t.jsx)(n.h2,{id:"installation-management",children:"Installation management"}),"\n",(0,t.jsxs)(n.p,{children:["So a subscription marks UGC as requiring installation, and an unsubscription indicates uninstallation, but how do you actually control when the plugin ",(0,t.jsx)(n.strong,{children:"does"})," those things? After all, you don\u2019t want UGC to be uninstalled after your main program has loaded those files into memory, locking them from deletion. Likewise, you probably don\u2019t want to be using networking or processor resources during gameplay for downloading mods. To give you control over when these processes occur without forcing you to shut down the plugin, you can call ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#enablemodmanagement",children:(0,t.jsx)(n.code,{children:"EnableModManagement"})})," and ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#disable-mod-management",children:(0,t.jsx)(n.code,{children:"DisableModManagement"})}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["To notify your users when UGC is finished installing or updating, ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#enablemodmanagement",children:(0,t.jsx)(n.code,{children:"EnableModManagement"})})," asks you to provide it with a callback. This callback will be invoked ",(0,t.jsx)(n.strong,{children:"every time"})," a ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#modiomodmanagementevent",children:(0,t.jsx)(n.code,{children:"ModioModManagementEvent"})})," occurs i.e. whenever UGC is installed, updated, uninstalled, or uploaded by the plugin\u2019s internal event loop. This behavior persists until a corresponding call to ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#disable-mod-management",children:(0,t.jsx)(n.code,{children:"DisableModManagement"})})," or ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#shutdownasync",children:(0,t.jsx)(n.code,{children:"ShutdownAsync"})})," is made."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"/unreal/refdocs#enablemodmanagement",children:(0,t.jsx)(n.code,{children:"EnableModManagement"})})," is not an async function.  It does not end with the ",(0,t.jsx)(n.code,{children:"*Async"})," suffix. Its callback operates differently to asynchronous result callbacks used elsewhere in the mod.io plugin."]})}),"\n",(0,t.jsxs)(r,{"group-id":"languages",children:[(0,t.jsx)(i,{value:"blueprint",label:"Blueprint",children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"enable_mod_management",src:s(97141).A+"",width:"1109",height:"751"})})}),(0,t.jsx)(i,{value:"c++",label:"C++",default:!0,children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'void UModioManagerSubsystem::EnableModManagement()\r\n{\r\n   if (UModioSubsystem* Subsystem = GEngine->GetEngineSubsystem<UModioSubsystem>())\r\n   {\r\n   \tSubsystem->EnableModManagement(FOnModManagementDelegateFast::CreateUObject(this, &UModioManagerSubsystem::ModManagementCallback));\r\n   }\r\n}\r\n\r\nvoid UModioManagerSubsystem::ModManagementCallback(FModioModManagementEvent ModManagementEvent)\r\n{\r\n   if (ModManagementEvent.Status)\r\n   {\r\n   \t// error handling\r\n   }\r\n   switch(ModManagementEvent.Event)\r\n   {\r\n   \tcase EModioModManagementEventType::BeginInstall:\r\n   \tcase EModioModManagementEventType::BeginUninstall:\r\n   \tcase EModioModManagementEventType::BeginUpdate:\r\n   \tcase EModioModManagementEventType::BeginUpload:\r\n   \t\tUE_LOG(LogModioGame, Log, TEXT("Begin processing Mod %s"), *ModManagementEvent.ID.ToString());\r\n   \t\tbreak;\r\n   \tcase EModioModManagementEventType::Installed:\r\n   \t\tUE_LOG(LogModioGame, Log, TEXT("Received an Installed event for Mod %s"), *ModManagementEvent.ID.ToString());\r\n   \t\tbreak;\r\n   \tcase EModioModManagementEventType::Uninstalled: \r\n   \t\tUE_LOG(LogModioGame, Log, TEXT("Received an Uninstalled event for Mod %s"), *ModManagementEvent.ID.ToString());\r\n   \t\tbreak;\r\n   \tcase EModioModManagementEventType::Updated:\r\n   \t\tUE_LOG(LogModioGame, Log, TEXT("Received an Updated event for Mod %s"), *ModManagementEvent.ID.ToString());\r\n   \t\tbreak;\r\n   \tcase EModioModManagementEventType::Uploaded:\r\n   \t\tUE_LOG(LogModioGame, Log, TEXT("Received an Uploaded event for Mod %s"), *ModManagementEvent.ID.ToString());\r\n   \t\tbreak;\r\n   \tdefault:;\r\n   }\r\n}\n'})})})]}),"\n",(0,t.jsxs)(n.p,{children:["While UGC management is enabled, the plugin assumes that it has the ability to make changes to the filesystem, including deleting UGC that the user has no longer subscribed to. As a result you should make sure that you don\u2019t have any open handles to files inside the UGC directories when you call ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#enablemodmanagement",children:(0,t.jsx)(n.code,{children:"EnableModManagement"})}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["When you want to be able to freely open files in the mod directories, call ",(0,t.jsx)(n.a,{href:"/unreal/refdocs#disable-mod-management",children:(0,t.jsx)(n.code,{children:"DisableModManagement"})}),". The plugin will finish the current operation but will not continue any others."]}),"\n",(0,t.jsxs)(n.p,{children:["Call ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#is-mod-management-busy",children:(0,t.jsx)(n.code,{children:"IsModManagementBusy"})})," to see if UGC management is currently processing UGC."]}),"\n",(0,t.jsxs)(r,{"group-id":"languages",children:[(0,t.jsx)(i,{value:"blueprint",label:"Blueprint",children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"disable_mod_management",src:s(59762).A+"",width:"1362",height:"267"})})}),(0,t.jsx)(i,{value:"c++",label:"C++",default:!0,children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"void UModioManagerSubsystem::DisableModManagement()\r\n{\r\n   if (UModioSubsystem* Subsystem = GEngine->GetEngineSubsystem<UModioSubsystem>())\r\n   {\r\n   \tif (!Subsystem->IsModManagementBusy())\r\n   \t{\r\n   \t\tSubsystem->DisableModManagement();\r\n   \t}\r\n   }\r\n}\n"})})})]}),"\n",(0,t.jsx)(n.h2,{id:"retrieving-ugc-directory-paths-for-loading",children:"Retrieving UGC directory paths for loading"}),"\n",(0,t.jsx)(n.p,{children:"So now we have the user picking UGC and marking them for installation, we\u2019re enabling mod management at a point where we don\u2019t mind the plugin changing the filesystem, and UGC is being installed by the plugin. We now need to know where they are on disk, otherwise you can\u2019t load them into your game!"}),"\n",(0,t.jsxs)(n.p,{children:["The easiest way to do this is by using ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#query-user-installations",children:(0,t.jsx)(n.code,{children:"QueryUserInstallations"})}),". This function returns a ",(0,t.jsx)(n.code,{children:"TMap"})," of ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#modiomodcollectionentry",children:(0,t.jsx)(n.code,{children:"ModioModCollectionEntry"})})," objects that can be queried for folder paths to use for loading a piece of UGC's files into your game. ",(0,t.jsx)(n.code,{children:"QueryUserInstallations"})," also allows you to specify whether or not to include outdated UGC."]}),"\n",(0,t.jsxs)(r,{"group-id":"languages",children:[(0,t.jsx)(i,{value:"blueprint",label:"Blueprint",children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"query_user_installations",src:s(55923).A+"",width:"1414",height:"255"})})}),(0,t.jsx)(i,{value:"c++",label:"C++",default:!0,children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"void UModioManagerSubsystem::GetInstalledMods()\r\n{\r\n   if (UModioSubsystem* Subsystem = GEngine->GetEngineSubsystem<UModioSubsystem>())\r\n   {\r\n   \tTMap<FModioModID, FModioModCollectionEntry> InstalledMods = Subsystem->QueryUserInstallations(false);\r\n   \t\r\n   \t// Do something with each installed mod, ie adding paths/loading the content appropriately\r\n   }\r\n}\n"})})})]}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,t.jsxs)(n.p,{children:["Now your users can search for and subscribe to UGC, you might want to start exploring ways for users to ",(0,t.jsx)(n.a,{href:"/unreal/adding-ugc",children:"Add UGC"})," to your game."]}),"\n",(0,t.jsxs)(n.p,{children:["If you've already done this, we recommend working your way through the ",(0,t.jsx)(n.a,{href:"/unreal/#unreal-engine-core-plugin-guides",children:"Unreal Getting Started Guides"})," as they will teach you how to implement the fundamentals of the Unreal Engine Plugin before moving onto exploring our ",(0,t.jsx)(n.a,{href:"/features/",children:"Features"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}function h(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},59762:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/disable_mod_management-d0c213302f8bcbd47e29d082d2ea6533.png"},97141:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/enable_mod_management-2a568b166cf68067c04f8ff543731857.png"},12102:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/fetch_external_updates-c214d37570186f79da44f59e70ff5763.png"},55923:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/query_user_installations-e37a6093723adc512887869302e45c29.png"},2030:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/query_user_subscriptions-985bf7a66a5aa502410ed36bc4d06b55.png"},31974:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/subscribe_to_mod-1867343f1ca55106c395c6a52cd45208.png"},26300:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/unsubscribe_from_mod-b2486db7a4aa665ec2bd5741b89cc04b.png"},28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var t=s(96540);const o={},i=t.createContext(o);function r(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);