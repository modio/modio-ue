"use strict";(self.webpackChunkmodio_docs=self.webpackChunkmodio_docs||[]).push([[6825],{20950:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>u});var t=s(74848),o=s(28453),r=s(27064),a=s(89236);const i={id:"ue-mod-subscriptions",title:"Mod Subscriptions & Management",slug:"/unreal/core-plugin/mod-subscriptions",custom_edit_url:"https://github.com/modio/modio-ue4-internal/blob/develop/Plugins/Modio/Doc/doc_root/en-us/getting-started/mod-subscriptions.mdx"},d=void 0,l={id:"core-plugin/ue-mod-subscriptions",title:"Mod Subscriptions & Management",description:"So you\u2019ve shown the user some mods, and they've picked one they\u2019d like to install. How do you begin the installation process? Once the mod is installed, how do you know what files to load into memory?",source:"@site/public/en-us/core-plugin/subscriptions.mdx",sourceDirName:"core-plugin",slug:"/unreal/core-plugin/mod-subscriptions",permalink:"/unreal/core-plugin/mod-subscriptions",draft:!1,unlisted:!1,editUrl:"https://github.com/modio/modio-ue4-internal/blob/develop/Plugins/Modio/Doc/doc_root/en-us/getting-started/mod-subscriptions.mdx",tags:[],version:"current",frontMatter:{id:"ue-mod-subscriptions",title:"Mod Subscriptions & Management",slug:"/unreal/core-plugin/mod-subscriptions",custom_edit_url:"https://github.com/modio/modio-ue4-internal/blob/develop/Plugins/Modio/Doc/doc_root/en-us/getting-started/mod-subscriptions.mdx"},sidebar:"sidebar",previous:{title:"Browsing Mods",permalink:"/unreal/core-plugin/browsing-mods"},next:{title:"In-Game Mod Submission",permalink:"/unreal/core-plugin/submit-mods"}},c={},u=[{value:"Mod subscriptions",id:"mod-subscriptions",level:2},{value:"External subscription changes",id:"external-subscription-changes",level:2},{value:"Checking the user subscription list",id:"checking-the-user-subscription-list",level:2},{value:"Installation management",id:"installation-management",level:2},{value:"Retrieving mod directory paths for loading",id:"retrieving-mod-directory-paths-for-loading",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["So you\u2019ve ",(0,t.jsx)(n.a,{href:"browsing-mods",children:"shown the user some mods"}),", and they've picked one they\u2019d like to install. How do you begin the installation process? Once the mod is installed, how do you know what files to load into memory?"]}),"\n",(0,t.jsx)(n.h2,{id:"mod-subscriptions",children:"Mod subscriptions"}),"\n",(0,t.jsxs)(n.p,{children:["Users indicate they want to install a mod by ",(0,t.jsx)(n.strong,{children:"subscribing"})," to it. Subscriptions are stored on the mod.io servers and are associated with a user\u2019s mod.io account, so subscribed mods for a given game will be installed to all devices where a user logs into mod.io for that game.  Similarly, when a user ",(0,t.jsx)(n.strong,{children:"unsubscribes"})," from a mod, that mod will be uninstalled from every device they\u2019re logged into mod.io with for that game."]}),"\n",(0,t.jsxs)(n.p,{children:["Subscriptions are managed with calls to either ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#subscribetomodasync",children:(0,t.jsx)(n.code,{children:"SubscribeToModAsync"})})," or ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#unsubscribefrommodasync",children:(0,t.jsx)(n.code,{children:"UnsubscribeFromModAsync"})})," containing the desired ",(0,t.jsx)(n.code,{children:"ModioModID"})," and a delegate to receive the status of the request."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["To subscribe or unsubscribe from a mod, ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#enablemodmanagement",children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"EnableModManagement"})})})," ",(0,t.jsx)(n.em,{children:"must"})," be called beforehand."]})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"SubscribeToModAsync"})," also takes a bool indicating whether or not to to subscribe to any and all dependencies for the given ",(0,t.jsx)(n.code,{children:"ModioModID"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["When dependencies are included in the ",(0,t.jsx)(n.code,{children:"SubscribeToModAsync"})," call, they will ",(0,t.jsx)(n.em,{children:"not"})," download automatically. ",(0,t.jsxs)(n.strong,{children:["Only the primary mod specified by ",(0,t.jsx)(n.code,{children:"ModioModID"})," will download automatically."]}),"  To download all subscribed content including dependencies, call ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#fetchexternalupdatesasync",children:(0,t.jsx)(n.code,{children:"FetchExternalUpdatesAsync"})})," after ",(0,t.jsx)(n.code,{children:"SubscribeToModAsync"})," successfully completes."]})}),"\n",(0,t.jsxs)(r.A,{"group-id":"languages",children:[(0,t.jsxs)(a.A,{value:"blueprint",label:"Blueprint",children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"subscribe_to_mod",src:s(42903).A+"",width:"898",height:"550"})}),(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"unsubscribe_from_mod",src:s(26197).A+"",width:"943",height:"547"})})]}),(0,t.jsx)(a.A,{value:"c++",label:"C++",default:!0,children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"void UModioManagerSubsystem::SubscribeToMod(FModioModID ModToSubscribeTo, bool IncludeDependencies)\r\n{\r\n   if (UModioSubsystem* Subsystem = GEngine->GetEngineSubsystem<UModioSubsystem>())\r\n   {\r\n   \tSubsystem->SubscribeToModAsync(ModId, IncludeDependencies, FOnErrorOnlyDelegateFast::CreateUObject(this, &UModioManagerSubsystem::OnSubscribeToModComplete, ModId));\r\n   }\r\n}\r\n\r\nvoid UModioManagerSubsystem::OnSubscribeToModComplete(FModioErrorCode ErrorCode, FModioModID ModId)\r\n{\r\n   if (!ErrorCode)\r\n   {\r\n   \t// Indicate success to your user. This ModId's files will begin installing.\r\n   \t// Call FetchExternalUpdatesAsync if dependencies were included \r\n   }\r\n}\r\n\r\nvoid UModioManagerSubsystem::UnsubscribeFromMod(FModioModID ModId)\r\n{\r\n   if (UModioSubsystem* Subsystem = GEngine->GetEngineSubsystem<UModioSubsystem>())\r\n   {\r\n   \tSubsystem->UnsubscribeFromModAsync(ModId, FOnErrorOnlyDelegateFast::CreateUObject(this, &UModioManagerSubsystem::OnUnsubscribeFromModComplete, ModId));\r\n   }\r\n}\r\n\r\nvoid UModioManagerSubsystem::OnUnsubscribeFromModComplete(FModioErrorCode ErrorCode, FModioModId ModId)\r\n{\r\n   if (!ErrorCode)\r\n   {\r\n   \t// Indicate success to your user. This ModID's files will begin uninstalling.\r\n   }\r\n}\n"})})})]}),"\n",(0,t.jsx)(n.h2,{id:"external-subscription-changes",children:"External subscription changes"}),"\n",(0,t.jsx)(n.p,{children:"Because mod.io's services are available via our website, users can manage their subscriptions outside of your application. This means that we need to be able to query the server for any external subscription changes."}),"\n",(0,t.jsxs)(n.p,{children:["Call ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#fetchexternalupdatesasync",children:(0,t.jsx)(n.code,{children:"FetchExternalUpdatesAsync"})})," to synchronise the server state with the plugin\u2019s local subscriptions.  Any required installations or uninstallations based on the updated user subscriptions will be processed automatically."]}),"\n",(0,t.jsxs)(r.A,{"group-id":"languages",children:[(0,t.jsx)(a.A,{value:"blueprint",label:"Blueprint",children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"fetch_external_updates",src:s(52019).A+"",width:"737",height:"364"})})}),(0,t.jsx)(a.A,{value:"c++",label:"C++",default:!0,children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"\r\nvoid UModioManagerSubsystem::FetchExternalUpdates()\r\n{\r\n   if (UModioSubsystem* Subsystem = GEngine->GetEngineSubsystem<UModioSubsystem>())\r\n   {\r\n   \tSubsystem->FetchExternalUpdatesAsync(FOnErrorOnlyDelegateFast::CreateUObject(this, &UModioManagerSubsystem::OnFetchExternalUpdatesComplete));\r\n   }\r\n}\r\n\r\nvoid UModioManagerSubsystem::OnFetchExternalUpdatesComplete(FModioErrorCode ErrorCode)\r\n{\r\n   // error handling etc.\r\n}\r\n\n"})})})]}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsxs)(n.p,{children:["Call ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#fetchexternalupdatesasync",children:(0,t.jsx)(n.code,{children:"FetchExternalUpdatesAsync"})})," sparingly, only when required to ensure that the local state is up-to-date such as on game start-up or based on user input (i.e. as a button on your UI). It should ",(0,t.jsx)(n.strong,{children:"NOT"})," be called on tick."]})}),"\n",(0,t.jsx)(n.h2,{id:"checking-the-user-subscription-list",children:"Checking the user subscription list"}),"\n",(0,t.jsxs)(n.p,{children:["To see which mods the user has subscribed to, call ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#query-user-subscriptions",children:(0,t.jsx)(n.code,{children:"QueryUserSubscriptions"})}),".  This retrieves a ",(0,t.jsx)(n.code,{children:"TMap"})," of ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#modiomodcollectionentry",children:(0,t.jsx)(n.code,{children:"ModioModCollectionEntry"})})," objects, one for each subscribed mod. Each ",(0,t.jsx)(n.code,{children:"ModioModCollectionEntry"})," object contains the mod\u2019s state, profile information, ID and more."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["This collection includes mods that are still in the process of being installed! Make sure to check the result of ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#get-mod-state",children:(0,t.jsx)(n.code,{children:"GetModState"})})," before attempting to load files from the mods in this collection.  Alternatively, use ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#query-user-installations",children:(0,t.jsx)(n.code,{children:"QueryUserInstallations"})})," as described in ",(0,t.jsx)(n.a,{href:"#retrieving-mod-directory-paths-for-loading",children:(0,t.jsx)(n.strong,{children:"Retrieving mod directory paths for loading"})}),"."]})}),"\n",(0,t.jsxs)(r.A,{"group-id":"languages",children:[(0,t.jsx)(a.A,{value:"blueprint",label:"Blueprint",children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"query_user_subscriptions",src:s(55055).A+"",width:"915",height:"357"})})}),(0,t.jsx)(a.A,{value:"c++",label:"C++",default:!0,children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"void UModioManagerSubsystem::QueryUserSubscriptions()\r\n{\r\n   if (UModioSubsystem* Subsystem = GEngine->GetEngineSubsystem<UModioSubsystem>())\r\n   {\r\n   \tTMap<FModioModID, FModioModCollectionEntry> SubscribedMods = Subsystem->QueryUserSubscriptions();\r\n   \t// Do something with SubscribedMods e.g. display on a UI\r\n   }\r\n}\n"})})})]}),"\n",(0,t.jsx)(n.h2,{id:"installation-management",children:"Installation management"}),"\n",(0,t.jsxs)(n.p,{children:["So a subscription marks a mod as requiring installation, and an unsubscription indicates uninstallation, but how do you actually control when the plugin ",(0,t.jsx)(n.strong,{children:"does"})," those things? After all, you don\u2019t want a mod to be uninstalled after your main program has loaded those files into memory, locking them from deletion. Likewise, you probably don\u2019t want to be using networking or processor resources during gameplay for downloading mods. To give you control over when these processes occur without forcing you to shut down the plugin, you can call ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#enablemodmanagement",children:(0,t.jsx)(n.code,{children:"EnableModManagement"})})," and ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#disable-mod-management",children:(0,t.jsx)(n.code,{children:"DisableModManagement"})}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["To notify your users when a mod is finished installing or updating, ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#enablemodmanagement",children:(0,t.jsx)(n.code,{children:"EnableModManagement"})})," asks you to provide it with a callback. This callback will be invoked ",(0,t.jsx)(n.strong,{children:"every time"})," a ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#modiomodmanagementevent",children:(0,t.jsx)(n.code,{children:"ModioModManagementEvent"})})," occurs i.e. whenever a mod is installed, updated, uninstalled, or uploaded by the plugin\u2019s internal event loop. This behavior persists until a corresponding call to ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#disable-mod-management",children:(0,t.jsx)(n.code,{children:"DisableModManagement"})})," or ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#shutdownasync",children:(0,t.jsx)(n.code,{children:"ShutdownAsync"})})," is made."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"/unreal/refdocs/#enablemodmanagement",children:(0,t.jsx)(n.code,{children:"EnableModManagement"})})," is not an async function.  It does not end with the ",(0,t.jsx)(n.code,{children:"*Async"})," suffix. Its callback operates differently to asynchronous result callbacks used elsewhere in the mod.io plugin."]})}),"\n",(0,t.jsxs)(r.A,{"group-id":"languages",children:[(0,t.jsx)(a.A,{value:"blueprint",label:"Blueprint",children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"enable_mod_management",src:s(80190).A+"",width:"1109",height:"751"})})}),(0,t.jsx)(a.A,{value:"c++",label:"C++",default:!0,children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'void UModioManagerSubsystem::EnableModManagement()\r\n{\r\n   if (UModioSubsystem* Subsystem = GEngine->GetEngineSubsystem<UModioSubsystem>())\r\n   {\r\n   \tSubsystem->EnableModManagement(FOnModManagementDelegateFast::CreateUObject(this, &UModioManagerSubsystem::ModManagementCallback));\r\n   }\r\n}\r\n\r\nvoid UModioManagerSubsystem::ModManagementCallback(FModioModManagementEvent ModManagementEvent)\r\n{\r\n   if (ModManagementEvent.Status)\r\n   {\r\n   \t// error handling\r\n   }\r\n   switch(ModManagementEvent.Event)\r\n   {\r\n   \tcase EModioModManagementEventType::BeginInstall:\r\n   \tcase EModioModManagementEventType::BeginUninstall:\r\n   \tcase EModioModManagementEventType::BeginUpdate:\r\n   \tcase EModioModManagementEventType::BeginUpload:\r\n   \t\tUE_LOG(LogModioGame, Log, TEXT("Begin processing Mod %s"), *ModManagementEvent.ID.ToString());\r\n   \t\tbreak;\r\n   \tcase EModioModManagementEventType::Installed:\r\n   \t\tUE_LOG(LogModioGame, Log, TEXT("Received an Installed event for Mod %s"), *ModManagementEvent.ID.ToString());\r\n   \t\tbreak;\r\n   \tcase EModioModManagementEventType::Uninstalled: \r\n   \t\tUE_LOG(LogModioGame, Log, TEXT("Received an Uninstalled event for Mod %s"), *ModManagementEvent.ID.ToString());\r\n   \t\tbreak;\r\n   \tcase EModioModManagementEventType::Updated:\r\n   \t\tUE_LOG(LogModioGame, Log, TEXT("Received an Updated event for Mod %s"), *ModManagementEvent.ID.ToString());\r\n   \t\tbreak;\r\n   \tcase EModioModManagementEventType::Uploaded:\r\n   \t\tUE_LOG(LogModioGame, Log, TEXT("Received an Uploaded event for Mod %s"), *ModManagementEvent.ID.ToString());\r\n   \t\tbreak;\r\n   \tdefault:;\r\n   }\r\n}\n'})})})]}),"\n",(0,t.jsxs)(n.p,{children:["While mod management is enabled, the plugin assumes that it has the ability to make changes to the filesystem, including deleting mods that the user has no longer subscribed to. As a result you should make sure that you don\u2019t have any open handles to files inside the mod directories when you call ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#enablemodmanagement",children:(0,t.jsx)(n.code,{children:"EnableModManagement"})}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["When you want to be able to freely open files in the mod directories, call ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#disable-mod-management",children:(0,t.jsx)(n.code,{children:"DisableModManagement"})}),". The plugin will finish the current operation but will not continue any others."]}),"\n",(0,t.jsxs)(n.p,{children:["Call ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#is-mod-management-busy",children:(0,t.jsx)(n.code,{children:"IsModManagementBusy"})})," to see if mod management is currently processing a mod."]}),"\n",(0,t.jsxs)(r.A,{"group-id":"languages",children:[(0,t.jsx)(a.A,{value:"blueprint",label:"Blueprint",children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"disable_mod_management",src:s(42083).A+"",width:"1362",height:"267"})})}),(0,t.jsx)(a.A,{value:"c++",label:"C++",default:!0,children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"void UModioManagerSubsystem::DisableModManagement()\r\n{\r\n   if (UModioSubsystem* Subsystem = GEngine->GetEngineSubsystem<UModioSubsystem>())\r\n   {\r\n   \tif (!Subsystem->IsModManagementBusy())\r\n   \t{\r\n   \t\tSubsystem->DisableModManagement();\r\n   \t}\r\n   }\r\n}\n"})})})]}),"\n",(0,t.jsx)(n.h3,{id:"retrieving-mod-directory-paths-for-loading",children:"Retrieving mod directory paths for loading"}),"\n",(0,t.jsx)(n.p,{children:"So now we have the user picking mods and marking them for installation, we\u2019re enabling mod management at a point where we don\u2019t mind the plugin changing the filesystem, and mods are being installed by the plugin. We now need to know where they are on disk, otherwise you can\u2019t load them into your game!"}),"\n",(0,t.jsxs)(n.p,{children:["The easiest way to do this is by using ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#query-user-installations",children:(0,t.jsx)(n.code,{children:"QueryUserInstallations"})}),". This function returns a ",(0,t.jsx)(n.code,{children:"TMap"})," of ",(0,t.jsx)(n.a,{href:"/unreal/refdocs/#modiomodcollectionentry",children:(0,t.jsx)(n.code,{children:"ModioModCollectionEntry"})})," objects that can be queried for folder paths to use for loading a mod's files into your game. ",(0,t.jsx)(n.code,{children:"QueryUserInstallations"})," also allows you to specify whether or not to include outdated mods."]}),"\n",(0,t.jsxs)(r.A,{"group-id":"languages",children:[(0,t.jsx)(a.A,{value:"blueprint",label:"Blueprint",children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"query_user_installations",src:s(33370).A+"",width:"1414",height:"255"})})}),(0,t.jsx)(a.A,{value:"c++",label:"C++",default:!0,children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"void UModioManagerSubsystem::GetInstalledMods()\r\n{\r\n   if (UModioSubsystem* Subsystem = GEngine->GetEngineSubsystem<UModioSubsystem>())\r\n   {\r\n   \tTMap<FModioModID, FModioModCollectionEntry> InstalledMods = Subsystem->QueryUserInstallations(false);\r\n   \t\r\n   \t// Do something with each installed mod, ie adding paths/loading the content appropriately\r\n   }\r\n}\n"})})})]})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},19365:(e,n,s)=>{s.d(n,{A:()=>a});s(96540);var t=s(18215);const o={tabItem:"tabItem_Ymn6"};var r=s(74848);function a(e){let{children:n,hidden:s,className:a}=e;return(0,r.jsx)("div",{role:"tabpanel",className:(0,t.A)(o.tabItem,a),hidden:s,children:n})}},11470:(e,n,s)=>{s.d(n,{A:()=>v});var t=s(96540),o=s(18215),r=s(23104),a=s(56347),i=s(205),d=s(57485),l=s(31682),c=s(70679);function u(e){return t.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,t.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:n,children:s}=e;return(0,t.useMemo)((()=>{const e=n??function(e){return u(e).map((e=>{let{props:{value:n,label:s,attributes:t,default:o}}=e;return{value:n,label:s,attributes:t,default:o}}))}(s);return function(e){const n=(0,l.X)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,s])}function m(e){let{value:n,tabValues:s}=e;return s.some((e=>e.value===n))}function b(e){let{queryString:n=!1,groupId:s}=e;const o=(0,a.W6)(),r=function(e){let{queryString:n=!1,groupId:s}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!s)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return s??null}({queryString:n,groupId:s});return[(0,d.aZ)(r),(0,t.useCallback)((e=>{if(!r)return;const n=new URLSearchParams(o.location.search);n.set(r,e),o.replace({...o.location,search:n.toString()})}),[r,o])]}function g(e){const{defaultValue:n,queryString:s=!1,groupId:o}=e,r=h(e),[a,d]=(0,t.useState)((()=>function(e){let{defaultValue:n,tabValues:s}=e;if(0===s.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:s}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${s.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const t=s.find((e=>e.default))??s[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:r}))),[l,u]=b({queryString:s,groupId:o}),[g,p]=function(e){let{groupId:n}=e;const s=function(e){return e?`docusaurus.tab.${e}`:null}(n),[o,r]=(0,c.Dv)(s);return[o,(0,t.useCallback)((e=>{s&&r.set(e)}),[s,r])]}({groupId:o}),f=(()=>{const e=l??g;return m({value:e,tabValues:r})?e:null})();(0,i.A)((()=>{f&&d(f)}),[f]);return{selectedValue:a,selectValue:(0,t.useCallback)((e=>{if(!m({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);d(e),u(e),p(e)}),[u,p,r]),tabValues:r}}var p=s(92303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var y=s(74848);function M(e){let{className:n,block:s,selectedValue:t,selectValue:a,tabValues:i}=e;const d=[],{blockElementScrollPositionUntilNextRender:l}=(0,r.a_)(),c=e=>{const n=e.currentTarget,s=d.indexOf(n),o=i[s].value;o!==t&&(l(n),a(o))},u=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const s=d.indexOf(e.currentTarget)+1;n=d[s]??d[0];break}case"ArrowLeft":{const s=d.indexOf(e.currentTarget)-1;n=d[s]??d[d.length-1];break}}n?.focus()};return(0,y.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.A)("tabs",{"tabs--block":s},n),children:i.map((e=>{let{value:n,label:s,attributes:r}=e;return(0,y.jsx)("li",{role:"tab",tabIndex:t===n?0:-1,"aria-selected":t===n,ref:e=>d.push(e),onKeyDown:u,onClick:c,...r,className:(0,o.A)("tabs__item",f.tabItem,r?.className,{"tabs__item--active":t===n}),children:s??n},n)}))})}function x(e){let{lazy:n,children:s,selectedValue:o}=e;const r=(Array.isArray(s)?s:[s]).filter(Boolean);if(n){const e=r.find((e=>e.props.value===o));return e?(0,t.cloneElement)(e,{className:"margin-top--md"}):null}return(0,y.jsx)("div",{className:"margin-top--md",children:r.map(((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==o})))})}function j(e){const n=g(e);return(0,y.jsxs)("div",{className:(0,o.A)("tabs-container",f.tabList),children:[(0,y.jsx)(M,{...n,...e}),(0,y.jsx)(x,{...n,...e})]})}function v(e){const n=(0,p.A)();return(0,y.jsx)(j,{...e,children:u(e.children)},String(n))}},89236:(e,n,s)=>{s.d(n,{A:()=>r});var t=s(19365),o=(s(96540),s(74848));function r(e){return(0,o.jsx)(o.Fragment,{children:(0,o.jsx)(t.A,{className:"tw-rounded-md",...e})})}},27064:(e,n,s)=>{s.d(n,{A:()=>r});var t=s(11470),o=(s(96540),s(74848));function r(e){return(0,o.jsx)("div",{className:"tw-border tw-border-solid tw-border-skyblue tw-rounded-md tw-bg-darkslategray tw-p-4 tw-mb-4",children:(0,o.jsx)(t.A,{...e})})}},42083:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/disable_mod_management-d0c213302f8bcbd47e29d082d2ea6533.png"},80190:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/enable_mod_management-2a568b166cf68067c04f8ff543731857.png"},52019:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/fetch_external_updates-c214d37570186f79da44f59e70ff5763.png"},33370:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/query_user_installations-e37a6093723adc512887869302e45c29.png"},55055:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/query_user_subscriptions-985bf7a66a5aa502410ed36bc4d06b55.png"},42903:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/subscribe_to_mod-1867343f1ca55106c395c6a52cd45208.png"},26197:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/unsubscribe_from_mod-b2486db7a4aa665ec2bd5741b89cc04b.png"},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>i});var t=s(96540);const o={},r=t.createContext(o);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);