"use strict";(self.webpackChunkmodio_docs=self.webpackChunkmodio_docs||[]).push([[8840],{64088:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>u,toc:()=>d});var s=n(74848),r=n(28453),a=n(27064),o=n(89236);const i={id:"ue-monetization",title:"Monetization",slug:"/unreal/getting-started/monetization",custom_edit_url:"https://github.com/modio/modio-ue4-internal/blob/develop/Plugins/Modio/Doc/getting-started/monetization.mdx"},l=void 0,u={id:"getting-started/ue-monetization",title:"Monetization",description:"The mod.io Unreal Engine Plugin supports a range of monetization features, allowing you to sell a per-game virtual currency to your players that they can use to purchase mods, with a share of the revenue split between creators and your studio. An overview of the mod.io monetization system is available here.",source:"@site/public/en-us/getting-started/monetization.mdx",sourceDirName:"getting-started",slug:"/unreal/getting-started/monetization",permalink:"/unreal/getting-started/monetization",draft:!1,unlisted:!1,editUrl:"https://github.com/modio/modio-ue4-internal/blob/develop/Plugins/Modio/Doc/getting-started/monetization.mdx",tags:[],version:"current",frontMatter:{id:"ue-monetization",title:"Monetization",slug:"/unreal/getting-started/monetization",custom_edit_url:"https://github.com/modio/modio-ue4-internal/blob/develop/Plugins/Modio/Doc/getting-started/monetization.mdx"},sidebar:"sidebar",previous:{title:"Error Handling",permalink:"/unreal/getting-started/error-handling"},next:{title:"Temporary Mod Sets",permalink:"/unreal/getting-started/temporary-mods"}},c={},d=[{value:"Initialization",id:"initialization",level:2},{value:"Getting the user&#39;s wallet",id:"getting-the-users-wallet",level:2},{value:"Querying mods",id:"querying-mods",level:2},{value:"Purchasing mods",id:"purchasing-mods",level:2},{value:"Showing user purchases",id:"showing-user-purchases",level:2},{value:"Getting a user delegation token",id:"getting-a-user-delegation-token",level:2}];function h(e){const t={a:"a",code:"code",h2:"h2",img:"img",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["The mod.io Unreal Engine Plugin supports a range of monetization features, allowing you to sell a per-game virtual currency to your players that they can use to purchase mods, with a share of the revenue split between creators and your studio. An overview of the mod.io monetization system is available ",(0,s.jsx)(t.a,{href:"/monetization/",children:"here"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Every platform requires specific setup for monetization features to work, particularly with respect to the virtual currency configuration and API calls.  The following documentation is generically applicable.  Platform-specific information is available in the relevant ",(0,s.jsx)(t.a,{href:"/platforms/",children:"platform documentation section"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"initialization",children:"Initialization"}),"\n",(0,s.jsxs)(t.p,{children:["The mod.io monetization features are enabled during the onboarding process on your ",(0,s.jsx)(t.a,{href:"https://mod.io/g",children:"game profile"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Ensure that you have set the appropriate ",(0,s.jsx)(t.code,{children:"Portal"})," when ",(0,s.jsx)(t.a,{href:"initialization",children:"initializing the plugin"}),". For instance, on Steam you must initialize with ",(0,s.jsx)(t.code,{children:"EModioPortal::Steam"})," to redeem entitlements for Steam."]}),"\n",(0,s.jsx)(t.h2,{id:"getting-the-users-wallet",children:"Getting the user's wallet"}),"\n",(0,s.jsxs)(t.p,{children:["On startup, you can make a call to ",(0,s.jsx)(t.code,{children:"UModioSubsystem::GetUserWalletBalanceAsync"})," to get the balance of the current user's wallet. If no wallet exists for the user, one will be automatically created for them. This call returns the user's wallet balance for the current game."]}),"\n",(0,s.jsxs)(t.p,{children:["The only time you need to make this call is on start-up.  We recommend that you cache the value of this result in your game code rather than making consistent calls to ",(0,s.jsx)(t.code,{children:"UModioSubsystem::GetUserWalletBalanceAsync"}),", and update your local state from the return values of other calls that affect wallet balance."]}),"\n",(0,s.jsxs)(a.A,{"group-id":"languages",children:[(0,s.jsx)(o.A,{value:"blueprint",label:"Blueprint",children:(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"get_user_wallet",src:n(80814).A+"",width:"598",height:"414"})})}),(0,s.jsx)(o.A,{value:"c++",label:"C++",default:!0,children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"void UModioManagerSubsystem::GetUserWallet()\n{\n   if (UModioSubsystem* Subsystem = GEngine->GetEngineSubsystem<UModioSubsystem>())\n   {\n   \tSubsystem->GetUserWalletBalanceAsync(FOnGetUserWalletBalanceDelegate::CreateUObject(this, &UModioManagerSubsystem::OnGetUserWalletComplete));\n   }\n}\n\nvoid UModioManagerSubsystem::OnGetUserWalletComplete(FModioErrorCode ErrorCode, FModioOptionalUInt64 WalletBalance)\n{\n   if (!ErrorCode)\n   {\n   \t// Wallet balance successfully retrieved\n   }\n}\n"})})})]}),"\n",(0,s.jsx)(t.h2,{id:"querying-mods",children:"Querying mods"}),"\n",(0,s.jsxs)(t.p,{children:["As part ",(0,s.jsx)(t.code,{children:"UModioSubsystem::ListAllModsAsync"}),", you can include an additional filter for whether you list paid mods. By default, only free mods are shown.  Set ",(0,s.jsx)(t.code,{children:"RevenueType"})," on the ",(0,s.jsx)(t.code,{children:"ModioFilterParams"})," object passed to ",(0,s.jsx)(t.code,{children:"UModioSubsystem::ListAllModsAsync"})," to include free and paid content, or just paid content. All mods returned will have a ",(0,s.jsx)(t.code,{children:"Price"})," property, indicating the virtual currency price that must be paid to purchase that mod."]}),"\n",(0,s.jsx)(t.p,{children:"Filtering for Paid/Unpaid content is not currently exposed to Blueprint."}),"\n",(0,s.jsx)(t.h2,{id:"purchasing-mods",children:"Purchasing mods"}),"\n",(0,s.jsxs)(t.p,{children:["Call ",(0,s.jsx)(t.code,{children:"UModioSubsystem::PurchaseModAsync"})," to purchase a specified mod. ",(0,s.jsx)(t.code,{children:"PurchaseModAsync"})," takes two parameters: the ",(0,s.jsx)(t.code,{children:"ModioModID"})," of the mod to purchase, and the ",(0,s.jsx)(t.code,{children:"ExpectedPrice"}),", which is the price displayed to the user from ",(0,s.jsx)(t.code,{children:"UModioSubsystem::ListAllModsAsync"}),". You must include this parameter for safety so the user is not charged more or less than the price displayed to them, in case the price of the mod has changed between the call to ",(0,s.jsx)(t.code,{children:"ListAllModsAsync"})," and purchase time."]}),"\n",(0,s.jsx)(t.p,{children:"Once a mod is purchased, it is automatically subscribed to for the user."}),"\n",(0,s.jsxs)(t.p,{children:["You should validate that the user has enough virtual currency to make the purchase by comparing it to the balance you received from ",(0,s.jsx)(t.code,{children:"UModioSubsystem::GetUserWalletBalanceAsync"}),". This is purely for user experience (e.g. for graying out the purchase button in the UI, or upselling the user a virtual currency pack); ",(0,s.jsx)(t.code,{children:"UModioSubsystem::PurchaseModAsync"})," will return an error if the user has insufficient funds in their wallet."]}),"\n",(0,s.jsxs)(t.p,{children:["An updated wallet balance (with the purchase amount subtracted) is returned in the callback of ",(0,s.jsx)(t.code,{children:"UModioSubsystem::PurchaseModAsync"}),"."]}),"\n",(0,s.jsxs)(a.A,{"group-id":"languages",children:[(0,s.jsx)(o.A,{value:"blueprint",label:"Blueprint",children:(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"purchase_mod",src:n(15154).A+"",width:"617",height:"442"})})}),(0,s.jsx)(o.A,{value:"c++",label:"C++",default:!0,children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"void UModioManagerSubsystem::PurchaseMod(FModioModID ModId, FModioUnsigned64 ExpectedPrice)\n{\n   if (UModioSubsystem* Subsystem = GEngine->GetEngineSubsystem<UModioSubsystem>())\n   {\n   \tSubsystem->PurchaseModAsync(ModId, ExpectedPrice, FOnPurchaseModDelegate::CreateUObject(this, &UModioManagerSubsystem::OnPurchaseModComplete));\n   }\n}\n\nvoid UModioManagerSubsystem::OnPurchaseModComplete(FModioErrorCode ErrorCode, FModioOptionalTransactionRecord Transaction)\n{\n   if (!ErrorCode)\n   {\n   \t// Mod purchase successful\n   }\n}\n"})})})]}),"\n",(0,s.jsx)(t.h2,{id:"showing-user-purchases",children:"Showing user purchases"}),"\n",(0,s.jsxs)(t.p,{children:["While purchased mods are automatically subscribed and installed at purchase time, the user can freely unsubscribe and uninstall purchased mods and they and they will remain owned and purchased by the user. They must re-subscribe to the mod to have it re-installed. Use ",(0,s.jsx)(t.code,{children:"UModioSubsystem::FetchUserPurchasesAsync"})," to fetch an updated list of a user's purchased mods from the server. After a successful call, you can then display the user's purchased mods with ",(0,s.jsx)(t.code,{children:"UModioSubsystem::QueryUserPurchasedMods"}),", allowing re-subscription as desired."]}),"\n",(0,s.jsxs)(a.A,{"group-id":"languages",children:[(0,s.jsx)(o.A,{value:"blueprint",label:"Blueprint",children:(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"show_user_purchases",src:n(97910).A+"",width:"580",height:"481"})})}),(0,s.jsx)(o.A,{value:"c++",label:"C++",default:!0,children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"void UModioManagerSubsystem::FetchUserPurchases()\n{\n   if (UModioSubsystem* Subsystem = GEngine->GetEngineSubsystem<UModioSubsystem>())\n   {\n   \tSubsystem->FetchUserPurchasesAsync(FOnFetchUserPurchasesDelegate::CreateUObject(this, &UModioManagerSubsystem::OnFetchUserPurchasesComplete));\n   }\n}\n\nvoid UModioManagerSubsystem::OnFetchUserPurchasesComplete(FModioErrorCode ErrorCode)\n{\n   if (!ErrorCode)\n   {\n   \t// Purchases Successfully Fetched\n   \tif (UModioSubsystem* Subsystem = GEngine->GetEngineSubsystem<UModioSubsystem>())\n   \t{\n   \t\t// We can now access the list of purchased mods directly\n   \t\tTMap<FModioModID, FModioModInfo> PurchasedMods = Subsystem->QueryUserPurchasedMods();\n   \t}\n   }\n}\n"})})})]}),"\n",(0,s.jsx)(t.h2,{id:"getting-a-user-delegation-token",children:"Getting a user delegation token"}),"\n",(0,s.jsxs)(t.p,{children:["User delegation tokens can be used by a backend server for S2S (Server to Server) transactions. You can get one for the current user by calling ",(0,s.jsx)(t.code,{children:"UModioSubsystem::GetUserDelegationTokenAsync"}),", the callback for which contains the token as an ",(0,s.jsx)(t.code,{children:"FString"}),"."]}),"\n",(0,s.jsxs)(a.A,{"group-id":"languages",children:[(0,s.jsx)(o.A,{value:"blueprint",label:"Blueprint",children:(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"get_user_delegation_token",src:n(94773).A+"",width:"670",height:"448"})})}),(0,s.jsx)(o.A,{value:"c++",label:"C++",default:!0,children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"void UModioManagerSubsystem::GetUserDelegationToken()\n{\n   if (UModioSubsystem* Subsystem = GEngine->GetEngineSubsystem<UModioSubsystem>())\n   {\n   \tSubsystem->GetUserDelegationTokenAsync(FOnGetUserDelegationTokenDelegateFast::CreateUObject(this, &UModioManagerSubsystem::OnGetUserDelegationTokenCallback));\n   }\n}\n\nvoid UModioManagerSubsystem::OnGetUserDelegationTokenCallback(FModioErrorCode ErrorCode, FString UserDelegationToken)\n{\n   if (!ErrorCode)\n   {\n   \t// Successfully got User Delegation Token\n   }\n}\n"})})})]})]})}function m(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},19365:(e,t,n)=>{n.d(t,{A:()=>o});n(96540);var s=n(18215);const r={tabItem:"tabItem_Ymn6"};var a=n(74848);function o(e){let{children:t,hidden:n,className:o}=e;return(0,a.jsx)("div",{role:"tabpanel",className:(0,s.A)(r.tabItem,o),hidden:n,children:t})}},11470:(e,t,n)=>{n.d(t,{A:()=>M});var s=n(96540),r=n(18215),a=n(23104),o=n(56347),i=n(205),l=n(57485),u=n(31682),c=n(70679);function d(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:t,children:n}=e;return(0,s.useMemo)((()=>{const e=t??function(e){return d(e).map((e=>{let{props:{value:t,label:n,attributes:s,default:r}}=e;return{value:t,label:n,attributes:s,default:r}}))}(n);return function(e){const t=(0,u.X)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function p(e){let{queryString:t=!1,groupId:n}=e;const r=(0,o.W6)(),a=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l.aZ)(a),(0,s.useCallback)((e=>{if(!a)return;const t=new URLSearchParams(r.location.search);t.set(a,e),r.replace({...r.location,search:t.toString()})}),[a,r])]}function g(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,a=h(e),[o,l]=(0,s.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const s=n.find((e=>e.default))??n[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:t,tabValues:a}))),[u,d]=p({queryString:n,groupId:r}),[g,b]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,a]=(0,c.Dv)(n);return[r,(0,s.useCallback)((e=>{n&&a.set(e)}),[n,a])]}({groupId:r}),f=(()=>{const e=u??g;return m({value:e,tabValues:a})?e:null})();(0,i.A)((()=>{f&&l(f)}),[f]);return{selectedValue:o,selectValue:(0,s.useCallback)((e=>{if(!m({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),b(e)}),[d,b,a]),tabValues:a}}var b=n(92303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var y=n(74848);function v(e){let{className:t,block:n,selectedValue:s,selectValue:o,tabValues:i}=e;const l=[],{blockElementScrollPositionUntilNextRender:u}=(0,a.a_)(),c=e=>{const t=e.currentTarget,n=l.indexOf(t),r=i[n].value;r!==s&&(u(t),o(r))},d=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const n=l.indexOf(e.currentTarget)+1;t=l[n]??l[0];break}case"ArrowLeft":{const n=l.indexOf(e.currentTarget)-1;t=l[n]??l[l.length-1];break}}t?.focus()};return(0,y.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":n},t),children:i.map((e=>{let{value:t,label:n,attributes:a}=e;return(0,y.jsx)("li",{role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,ref:e=>l.push(e),onKeyDown:d,onClick:c,...a,className:(0,r.A)("tabs__item",f.tabItem,a?.className,{"tabs__item--active":s===t}),children:n??t},t)}))})}function x(e){let{lazy:t,children:n,selectedValue:r}=e;const a=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=a.find((e=>e.props.value===r));return e?(0,s.cloneElement)(e,{className:"margin-top--md"}):null}return(0,y.jsx)("div",{className:"margin-top--md",children:a.map(((e,t)=>(0,s.cloneElement)(e,{key:t,hidden:e.props.value!==r})))})}function j(e){const t=g(e);return(0,y.jsxs)("div",{className:(0,r.A)("tabs-container",f.tabList),children:[(0,y.jsx)(v,{...t,...e}),(0,y.jsx)(x,{...t,...e})]})}function M(e){const t=(0,b.A)();return(0,y.jsx)(j,{...e,children:d(e.children)},String(t))}},89236:(e,t,n)=>{n.d(t,{A:()=>a});var s=n(19365),r=(n(96540),n(74848));function a(e){return(0,r.jsx)(r.Fragment,{children:(0,r.jsx)(s.A,{className:"tw-rounded-md",...e})})}},27064:(e,t,n)=>{n.d(t,{A:()=>a});var s=n(11470),r=(n(96540),n(74848));function a(e){return(0,r.jsx)("div",{className:"tw-border tw-border-solid tw-border-skyblue tw-rounded-md tw-bg-darkslategray tw-p-4 tw-mb-4",children:(0,r.jsx)(s.A,{...e})})}},94773:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/get_user_delegation_token-9ae69e059f28541bbac934ea02b8f994.png"},80814:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/get_user_wallet-3e8cab6076988d8cc7469c3183f8711b.png"},15154:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/purchase_mod-d1e2b2ee8586f08eada43e87167ee125.png"},97910:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/show_user_purchases-575ecaef025b90bbf3ea30f2c0437cfe.png"},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var s=n(96540);const r={},a=s.createContext(r);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);