/*
 *  Copyright (C) 2021 mod.io Pty Ltd. <https://mod.io>
 *
 *  This file is part of the mod.io UE4 Plugin.
 *
 *  Distributed under the MIT License. (See accompanying file LICENSE or
 *   view online at <https://github.com/modio/modio-ue4/blob/main/LICENSE>)
 *
 */

#pragma once

#include "Brushes/SlateImageBrush.h"
#include "Containers/UnrealString.h"
#include "Engine/Texture2DDynamic.h"
#include "IStructureDetailsView.h"
#include "MaterialEditingLibrary.h"
#include "MaterialEditorModule.h"
#include "MaterialEditorUtilities.h"
#include "Materials/MaterialExpressionComponentMask.h"
#include "Materials/MaterialExpressionConstant.h"
#include "Materials/MaterialExpressionConstant3Vector.h"
#include "Materials/MaterialExpressionScalarParameter.h"
#include "Materials/MaterialExpressionVectorParameter.h"
#include "Misc/NotifyHook.h"
#include "Modules/ModuleManager.h"
#include "PropertyEditorModule.h"
#include "RenderMSDF.h"
#include "SVGToSDF.h"
#include "ShaderCompiler.h"
#include "SlateMaterialBrush.h"
#include "Templates/SharedPointer.h"
#include "UObject/StrongObjectPtr.h"
#include "UObject/StructOnScope.h"
#include "Widgets/DeclarativeSyntaxSupport.h"
#include "Widgets/Images/SImage.h"
#include "Widgets/Input/SButton.h"
#include "Widgets/Input/SSlider.h"
#include "Widgets/Layout/SBox.h"
#include "Widgets/Layout/SGridPanel.h"
#include "Widgets/Layout/SScaleBox.h"
#include "Widgets/SCompoundWidget.h"
#include "Widgets/Text/STextBlock.h"

UENUM()
enum class EImportSVGDialogReturnType : uint8
{
	Open,
	Confirmed,
	Cancelled
};

DECLARE_DELEGATE_OneParam(FOnImportSVGDialogClosed, EImportSVGDialogReturnType);

class SImportSVGOptionsWidget : public SCompoundWidget, public FNotifyHook
{
public:
	SLATE_BEGIN_ARGS(SImportSVGOptionsWidget) {}
	SLATE_ARGUMENT(TSharedPtr<FSVGConversionParams>, OptionsToEdit);
	SLATE_EVENT(FOnImportSVGDialogClosed, OnDialogClosed);
	SLATE_EVENT(FSimpleDelegate, OnUpdatePreview);
	SLATE_ARGUMENT(UTexture2DDynamic*, SDFPreviewTexture);
	SLATE_ARGUMENT(UTexture2DDynamic*, RenderedTexture);
	SLATE_END_ARGS()

	void Construct(const FArguments& InArgs)
	{
		OnUpdatePreview = InArgs._OnUpdatePreview;
		OnDialogClosed = InArgs._OnDialogClosed;
		OptionsToEdit = InArgs._OptionsToEdit;
		OptionsStructWrapper =
			MakeShared<FStructOnScope>(FSVGConversionParams::StaticStruct(), (uint8*) OptionsToEdit.Get());
		UTexture2DDynamic* SDFPreviewTexture = InArgs._SDFPreviewTexture;
		UTexture2DDynamic* RenderedTexture = InArgs._RenderedTexture;
		// Create a brush to draw a preview of the SDF texture generated by msdfgen
		SDFImageBrush = MakeShared<FSlateImageBrush>((UObject*) SDFPreviewTexture, OptionsToEdit->OutputDimensions);
		SDFImageBrush->DrawAs = ESlateBrushDrawType::Box;
		SDFImageBrush->Margin = FMargin(0);
		// Create a new temporary UMaterial that will actually render the SDF the way it would be done in-game. Use a
		// TStrongObjectPtr to ensure the UMaterial doesn't go out of scope
		RenderedMaterialInstance = TStrongObjectPtr<UMaterial>(NewObject<UMaterial>());
		// Add nodes to our material. First the actual RenderMSDF node
		URenderMSDF* PreviewRenderExpression = NewObject<URenderMSDF>(RenderedMaterialInstance.Get());
		// Tell the node to use the SDF preview texture as it's input. This is a UPROPERTY member so will keep the
		// SDFPreviewTexture alive if necessary
		PreviewRenderExpression->Texture = Cast<UTexture>(SDFPreviewTexture);
		// Add some parameters for the field distance and output image size
		UMaterialExpressionScalarParameter* FieldDistance =
			NewObject<UMaterialExpressionScalarParameter>(RenderedMaterialInstance.Get());
		FieldDistance->SetParameterName("FieldDistance");
		FieldDistance->DefaultValue = OptionsToEdit->FieldRangeInPixels;
		PreviewRenderExpression->FieldDistance.Connect(0, FieldDistance);
		UMaterialExpressionVectorParameter* OutputImageSize =
			NewObject<UMaterialExpressionVectorParameter>(RenderedMaterialInstance.Get());
		OutputImageSize->SetParameterName("OutputImageSize");
		OutputImageSize->DefaultValue = FLinearColor(256, 256, 0);
		// Output Image Size is a vector parameter so use a mask to grab the first 2 components as our X and Y values
		UMaterialExpressionComponentMask* ComponentMask =
			NewObject<UMaterialExpressionComponentMask>(RenderedMaterialInstance.Get());
		ComponentMask->R = true;
		ComponentMask->G = true;
		ComponentMask->B = false;
		ComponentMask->A = false;
		ComponentMask->Input.Connect(0, OutputImageSize);
		PreviewRenderExpression->OutputTextureSize.Connect(0, ComponentMask);
		// Add all the expressions so far to this material
		RenderedMaterialInstance->Expressions.Add(PreviewRenderExpression);
		RenderedMaterialInstance->Expressions.Add(FieldDistance);
		RenderedMaterialInstance->Expressions.Add(OutputImageSize);
		RenderedMaterialInstance->Expressions.Add(ComponentMask);
		RenderedMaterialInstance->MaterialDomain = EMaterialDomain::MD_UI;
		RenderedMaterialInstance->BlendMode = BLEND_Translucent;
		// Use a flat white color for the rendered preview
		UMaterialExpressionConstant3Vector* Color =
			NewObject<UMaterialExpressionConstant3Vector>(RenderedMaterialInstance.Get());
		Color->Constant = FLinearColor(1, 1, 1, 1);
		RenderedMaterialInstance->EmissiveColor.Connect(0, Color);
		RenderedMaterialInstance->Expressions.Add(Color);
		// Use the rendered MSDF as the opacity mask for the material
		UMaterialExpressionConstant* OpacityValue =
			NewObject<UMaterialExpressionConstant>(RenderedMaterialInstance.Get());
		OpacityValue->R = 1;
		RenderedMaterialInstance->Opacity.Connect(0, PreviewRenderExpression);
		RenderedMaterialInstance->SetShadingModel(MSM_Unlit);
		// Notify the material it's been edited
		RenderedMaterialInstance->PreEditChange(nullptr);
		RenderedMaterialInstance->PostEditChange();

		RenderedMaterialInstance->UpdateCachedExpressionData();
		{
			FMaterialUpdateContext UpdateContext;
			UpdateContext.AddMaterial(RenderedMaterialInstance.Get());
		}
		UMaterialEditingLibrary::LayoutMaterialExpressions(RenderedMaterialInstance.Get());
		GShaderCompilingManager->FinishAllCompilation();
		FlushRenderingCommands();
		// For debugging the preview material only, not for use normally
		// GEditor->GetEditorSubsystem<UAssetEditorSubsystem>()->OpenEditorForAsset(RenderedMaterialInstance.Get());

		// Create a new Slate Brush to render the material previewing the rendered MSDF
		RenderedImageBrush = MakeShared<FSlateMaterialBrush>(*(RenderedMaterialInstance.Get()), FVector2D(256, 256));
		RenderedImageBrush->DrawAs = ESlateBrushDrawType::Box;
		RenderedImageBrush->Margin = FMargin(0);
		FPropertyEditorModule& PropertyModule =
			FModuleManager::LoadModuleChecked<FPropertyEditorModule>("PropertyEditor");

		FDetailsViewArgs ParamsDetailsViewArgs;
		ParamsDetailsViewArgs.NotifyHook = this;
		FStructureDetailsViewArgs StructDetailsViewArgs;
		// clang-format off
		ChildSlot
		[
			SNew(SVerticalBox)
			+ SVerticalBox::Slot()
			[
				SNew(SGridPanel)
				.FillColumn(0, 1)
				.FillColumn(1,1)
				.FillColumn(2,1.25)
				.FillRow(0,1)
				+ SGridPanel::Slot(0, 0).HAlign(HAlign_Fill)
				[
					SNew(SScaleBox)
					.Stretch(EStretch::Type::ScaleToFit)
					.Content()
					[
						SAssignNew(SDFPreviewImage, SImage).Image(SDFImageBrush.Get())
					]
				] + SGridPanel::Slot(1,0)
				[
					SNew(SVerticalBox)
					+SVerticalBox::Slot()
					.HAlign(HAlign_Fill)
					[
						SNew(SScaleBox)
						.Stretch(EStretch::Type::ScaleToFit)
						.Content()
						[
							SAssignNew(RenderedPreviewImage, SImage).Image(RenderedImageBrush.Get())
						]
					]
					/* Letting the user directly adjust the preview value didn't make a lot of sense and is disabled
					+SVerticalBox::Slot()
					.HAlign(HAlign_Fill)
					.AutoHeight()
					[
						SNew(SHorizontalBox)
						+SHorizontalBox::Slot()
						.HAlign(HAlign_Right)
						.AutoWidth()
						.Padding(FMargin(0,0,4,0))
						[
							SNew(STextBlock)
							.Text(FText::FromString("Preview Size:"))
						]
						+SHorizontalBox::Slot()
						.HAlign(HAlign_Fill)
						.FillWidth(1)
						[
							SNew(SSlider)
							.MinValue(0)
							.StepSize(1)
							.MaxValue(4)
							.Value(3)
							.MouseUsesStep(true)
							.OnValueChanged(this, &SImportSVGOptionsWidget::PreviewSizeChanged)
						]
						+ SHorizontalBox::Slot()
						.HAlign(HAlign_Right)
						.AutoWidth()
						.Padding(FMargin(0, 0, 4, 0))
						[
							SAssignNew(PreviewSizeLabel, STextBlock).Text(FText::AsNumber(256))
						]
					]
					*/
				] + SGridPanel::Slot(2, 0)
				[
					PropertyModule.CreateStructureDetailView(
						ParamsDetailsViewArgs, StructDetailsViewArgs, OptionsStructWrapper,
						FText::FromString("Parameters"))->GetWidget().ToSharedRef()
				]
			]+SVerticalBox::Slot()
			.AutoHeight()
			[
				SNew(SHorizontalBox)
				+ SHorizontalBox::Slot().HAlign(HAlign_Left).FillWidth(1)
				[
					SNew(SButton)
					.Content()
					[
						SNew(STextBlock)
						.Text(FText::FromString("Update Preview"))
					]
					.OnClicked(this, &SImportSVGOptionsWidget::UpdatePreview)
				]
				
				+ SHorizontalBox::Slot().AutoWidth()
				[
					SNew(SButton)
					.Content()
					[
						SNew(STextBlock)
						.Text(FText::FromString("OK"))
					]
					.OnClicked(this, &SImportSVGOptionsWidget::CloseDialog, EImportSVGDialogReturnType::Confirmed)
				]
				+SHorizontalBox::Slot().AutoWidth()
				[
					SNew(SButton)
					.Content()
					[
						SNew(STextBlock)
						.Text(FText::FromString("Cancel"))
					]
					.OnClicked(this, &SImportSVGOptionsWidget::CloseDialog, EImportSVGDialogReturnType::Cancelled)
				]
			]
		];
		// clang-format on
	}

protected:
	FReply CloseDialog(EImportSVGDialogReturnType Return)
	{
		// Notify the enclosing scope why the dialog was closed
		if (OnDialogClosed.IsBound())
		{
			OnDialogClosed.Execute(Return);
		}
		return FReply::Handled();
	}
	void PreviewSizeChanged(float NewPreviewSize)
	{
		int32 PreviewSizeIndex = FMath::RoundToInt(NewPreviewSize);
		int32 CalculatedSize = PreviewSizes[PreviewSizeIndex];
		PreviewSizeLabel->SetText(FText::AsNumber(CalculatedSize));
		RenderedImageBrush->SetImageSize(FVector2D(CalculatedSize, CalculatedSize));
		RenderedMaterialInstance->SetVectorParameterValueEditorOnly("OutputImageSize",
																	FLinearColor(CalculatedSize, CalculatedSize, 0));
		RenderedMaterialInstance->PreEditChange(nullptr);
		RenderedMaterialInstance->PostEditChange();

		RenderedMaterialInstance->UpdateCachedExpressionData();
		{
			FMaterialUpdateContext UpdateContext;
			UpdateContext.AddMaterial(RenderedMaterialInstance.Get());
		}
		GShaderCompilingManager->FinishAllCompilation();
		FlushRenderingCommands();
	}

	FReply UpdatePreview()
	{
		// Update the material's parameters based on the values from the UI
		RenderedMaterialInstance->SetScalarParameterValueEditorOnly("FieldDistance", OptionsToEdit->FieldRangeInPixels);
		RenderedMaterialInstance->SetVectorParameterValueEditorOnly(
			"OutputImageSize",
			FLinearColor(RenderedPreviewImage->GetDesiredSize().X, RenderedPreviewImage->GetDesiredSize().Y, 0));

		if (OnUpdatePreview.IsBound())
		{
			OnUpdatePreview.Execute();
		}

		// Notify the material it was changed and flush all pending rendering work so that the preview updates when used
		// in a blocking import dialog
		RenderedMaterialInstance->PreEditChange(nullptr);
		RenderedMaterialInstance->PostEditChange();

		RenderedMaterialInstance->UpdateCachedExpressionData();
		{
			FMaterialUpdateContext UpdateContext;
			UpdateContext.AddMaterial(RenderedMaterialInstance.Get());
		}
		GShaderCompilingManager->FinishAllCompilation();
		FlushRenderingCommands();

		return FReply::Handled();
	}
	TSharedPtr<FStructOnScope> OptionsStructWrapper;
	TSharedPtr<FSVGConversionParams> OptionsToEdit;
	TSharedPtr<SImage> SDFPreviewImage;
	TSharedPtr<SImage> RenderedPreviewImage;
	FOnImportSVGDialogClosed OnDialogClosed;
	FSimpleDelegate OnUpdatePreview;
	TSharedPtr<FSlateImageBrush> SDFImageBrush;
	TSharedPtr<FSlateMaterialBrush> RenderedImageBrush;
	TStrongObjectPtr<UMaterial> RenderedMaterialInstance;
	TSharedPtr<STextBlock> PreviewSizeLabel;

	TArray<int32> PreviewSizes = TArray<int> {32, 64, 128, 256, 512};

	virtual void NotifyPostChange(const FPropertyChangedEvent& PropertyChangedEvent,
								  class FEditPropertyChain* PropertyThatChanged) override
	{
		UpdatePreview();
	}
	virtual void NotifyPostChange(const FPropertyChangedEvent& PropertyChangedEvent,
								  FProperty* PropertyThatChanged) override
	{
		UpdatePreview();
	}
};
